import{_ as e,o as r,c as a,a as t}from"./app.255488f9.js";const h=JSON.parse('{"title":"요약: 네 시대의 자바스크립트 프레임워크","description":"","frontmatter":{},"headers":[],"relativePath":"log/short/four-eras-of-javascript-frameworks.md","lastUpdated":1671365980000}'),o={name:"log/short/four-eras-of-javascript-frameworks.md"},s=t('<h1 id="요약-네-시대의-자바스크립트-프레임워크" tabindex="-1">요약: 네 시대의 자바스크립트 프레임워크 <a class="header-anchor" href="#요약-네-시대의-자바스크립트-프레임워크" aria-hidden="true">#</a></h1><blockquote><p>원문: <a href="https://www.pzuraq.com/blog/four-eras-of-javascript-frameworks" target="_blank" rel="noreferrer">Four Eras of JavaScript Frameworks</a></p></blockquote><p>자바스크립트 생태계는 올바르게 나아가고 있다.</p><p>이전 2개의 시대를 지나면서 여러 교훈을 얻고 발전해나가고 있음</p><p>3세대 프레임워크(Next.js, Nuxt.js, SveltKit, Remix 등)들은 1세대가 목표했던 올인원 솔루션을 다시 목표로 하고 있음.</p><p>2세대 프레임워크(React.js, Vue.js, Svelte) 겪었던 문제들을 해결해면서 장점들도 가져가고 있다.</p><ul><li>문제들 : 라우팅, SSR, API 통신, 상태관리 등은 여전히 개발자들에게 맡겼음. 선택지가 지나치게 많아 제한된 자원을 가진 개발자들이 개발하면서 문제를 만들어내게 되는 경우가 생김</li></ul><p>3세대 프레임워크의 주요 초점들</p><ul><li>우리는 컴포넌트가 기반이 되는 핵심 요소라는데 동의했으므로, 라우터, 빌드 시스템, 폴더 구조 등 앱의 다른 부분을 표준화하는 것이 합리적이었음</li><li>특정 요청에 대한 API secret 숨기기, 페이지 반환 시 헤더 수정, API 요청 프록시와 같은 작업을 수행할 수 있도록 백엔드와 프런트엔드를 함께 사용하는 것이 매우 유용하다는 것을 알았다.</li><li>최신 프레임워크는 그 잠재력을 최대한 활용하여 클라이언트와 서버의 통합을 원활하게 하고 있다. =&gt; 마침내 우리는 네이티브 앱용 SDK와 동일한 환경에서 경쟁하기 시작</li></ul><p>기타 키워드들</p><ul><li><p>웹 컴포넌트</p><ul><li>웹 컴포넌트는 조용히 발전하며 SSR과 같은 문제에 대한 솔루션을 작업하고 전역 등록을 제거해 3세대 프레임워크와 호환이 더 잘되도록 하고 있음</li></ul></li><li><p>웹어셈블리</p><ul><li>Rust, 파이썬, 스위프트, 자바 등은 더 나은 UX와 함께 마침내 프런트엔드와 백엔드 사이의 장벽을 거의 0으로 줄일 수 있음</li></ul></li></ul>',11),l=[s];function i(p,c,_,u,n,f){return r(),a("div",null,l)}const m=e(o,[["render",i]]);export{h as __pageData,m as default};
